require('dotenv').config(); // Âä†Ëºâ .env Êñá‰ª∂‰∏≠ÁöÑËÆäÊï∏
const { DISCORD_BOT_TOKEN, FFMPEG_PATH } = process.env;

const { Client, GatewayIntentBits, StringSelectMenuBuilder, ActionRowBuilder, EmbedBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const { DisTube } = require('distube');
const { YtDlpPlugin } = require('@distube/yt-dlp');
const ytSearch = require('yt-search'); // ÂºïÂÖ• yt-search Ê®°ÁµÑ

const ffmpeg = require('@ffmpeg-installer/ffmpeg'); // ÂºïÁî® ffmpeg Ê®°ÁµÑ
// const { generateDependencyReport } = require('@discordjs/voice');
// console.log(generateDependencyReport());

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
  ]
});
let idleTimeout;


// ÂàùÂßãÂåñ DisTube
const distube = new DisTube(client, {
  plugins: [new YtDlpPlugin({ update: true})],
  ffmpeg: {
    path: FFMPEG_PATH
  }
});

client.once('ready', async () => {
  console.log(`${client.user.tag} Â∑≤‰∏äÁ∑öÔºÅ`);
  // ÂïüÂãïÊôÇÊ™¢Êü•ÊòØÂê¶ÊúâÊí≠ÊîæÈöäÂàóÔºåÂ¶ÇÊûúÊ≤íÊúâÂâáËá™ÂãïÊí≠ÊîæÈ†êË®≠ÂΩ±Áâá
  // ÂïüÂãïÊôÇË®≠ÁΩÆ30ÁßíË®àÊôÇÂô®ÔºåÂ¶ÇÊûúÊ≤íÊúâÊí≠Êîæ‰ªª‰ΩïÈü≥Ê®ÇÔºåÂâáËá™ÂãïÊí≠ÊîæÈ†êË®≠ÂΩ±Áâá
  idleTimeout = setTimeout(async () => {
    const guilds = client.guilds.cache;
    guilds.forEach(async (guild) => {
      const voiceChannel = guild.members.me?.voice.channel;
      if (voiceChannel && !distube.getQueue(guild.id)) {
        try {
          await distube.play(voiceChannel, 'https://www.youtube.com/watch?v=NZoXV828Suo&pp=ygUN5aSa57Gz5aSa576FIA%3D%3D', {
            textChannel: guild.channels.cache.find(channel =>
              channel.type === 0 && channel.permissionsFor(guild.members.me).has('SendMessages')
            ),
          });
          console.log('ÂïüÂãï30ÁßíÂæåÊ≤íÊúâÊí≠ÊîæÈü≥Ê®ÇÔºåËá™ÂãïÊí≠ÊîæÈ†êË®≠ÂΩ±Áâá„ÄÇ');
        } catch (error) {
          console.error('Ëá™ÂãïÊí≠ÊîæÂΩ±ÁâáÊôÇÁôºÁîüÈåØË™§:', error);
        }
      }
    });
  }, 60000); // Ë®≠ÂÆöÁÇ∫ 30 Áßí
});

// Èü≥Ê®ÇÊí≠ÊîæÊåá‰ª§
client.on('messageCreate', async (message) => {
  if (message.author.bot || !message.guild) return;

  const args = message.content.split(' ');
  const command = args.shift();
  const input = args.join(' '); // ÈáçÊñ∞ÁµÑÂêàÂëΩ‰ª§ÂæåÁöÑÂèÉÊï∏

  if (command === '!play') {
    let url;
    if (input.startsWith('http')) {
      url = input; // Â¶ÇÊûúÊòØ URLÔºåÂâáÁõ¥Êé•‰ΩøÁî®
    } else {
      // ‰ΩøÁî® yt-search ÈÄ≤Ë°åÊêúÂ∞ã
      const results = await ytSearch(input);
      if (results.videos.length > 0) {
        // Âª∫Á´ãÈÅ∏Êìámenu
        const options = results.videos.map((video, index) => ({
          label: video.title.length > 50 ? video.title.slice(0, 50) + '...' : video.title, // Á¢∫‰øùÊ®ôÁ±§‰∏çË∂ÖÈÅé 25 ÂÄãÂ≠óÁ¨¶
          value: video.url,
          description: `${video.duration.timestamp}`
        }));

        const selectMenu = new StringSelectMenuBuilder()
          .setCustomId('songSelect')
          .setPlaceholder('Ë´ãÈÅ∏Êìá‰∏ÄÈ¶ñÊ≠åÊõ≤')
          .addOptions(options);

        const row = new ActionRowBuilder().addComponents(selectMenu);

        await message.channel.send({ content: 'ÊâæÂà∞‰ª•‰∏ãÊ≠åÊõ≤ÔºåË´ãÈÅ∏ÊìáÔºö', components: [row] });
        // È°ØÁ§∫ÊêúÂ∞ãÁµêÊûú
        // const songs = results.videos.map((video, index) => `**${index + 1}**: ${video.title}`).join('\n');
        // message.channel.send(`ÊâæÂà∞‰ª•‰∏ãÊ≠åÊõ≤Ôºö\n${songs}\nË´ãËº∏ÂÖ•Êï∏Â≠ó‰æÜÈÅ∏ÊìáË¶ÅÊí≠ÊîæÁöÑÊ≠åÊõ≤„ÄÇ`);

        // Á≠âÂæÖÁî®Êà∂Ëº∏ÂÖ•
        const filter = i => i.customId === 'songSelect' && i.user.id === message.author.id;
        const collected = await message.channel.awaitMessageComponent({ filter, time: 30000 }).catch(() => {
          // message.reply('ÈÅ∏ÊìáË∂ÖÊôÇÔºÅ');
        });

        if (collected) {
          url = collected.values[0];
          selectedTitle = options.find(option => option.value === url).label;
          await collected.reply({ content: `Â∑≤ÈÅ∏ÊìáÊ≠åÊõ≤: ${selectedTitle}`, ephemeral: true }); // ephemeralÂè™ÊúâsenderÁúãÁöÑÂà∞
        }

      } else {
        message.reply('Êâæ‰∏çÂà∞‰ªª‰ΩïÈü≥Ê®Ç„ÄÇ');
        return;
      }
    }

    if (url && message.member.voice.channel) {
      // Ë®òÈåÑÊäìÈü≥Ê®ÇÈñãÂßãÊôÇÈñì
      const addListStartTime = Date.now();
      console.log('ÈñãÂßãÊäìÈü≥Ê®Ç:', new Date(addListStartTime).toLocaleTimeString());
      try {
        await distube.play(message.member.voice.channel, url, {
          member: message.member,
          textChannel: message.channel,
          message
        });
      } catch (error) {
        console.log(error)
        if (error.errorCode === 'YTDLP_ERROR') {
          message.reply({ content: 'ÊäìÈü≥Ê®ÇÂ§±ÊïóÔºÅ', ephemeral: true });
        }
      }

    } else {
      message.reply('‰Ω†ÈúÄË¶ÅÂÖàÂä†ÂÖ•Ë™ûÈü≥È†ªÈÅìÔºÅ');
    }
  }

  if (command === '!insert') {
    let url;
    if (input.startsWith('http')) {
      url = input; // Â¶ÇÊûúÊòØ URLÔºåÂâáÁõ¥Êé•‰ΩøÁî®
    } else {
      // ‰ΩøÁî® yt-search ÈÄ≤Ë°åÊêúÂ∞ã
      const results = await ytSearch(input);
      if (results.videos.length > 0) {
        // Âª∫Á´ãÈÅ∏Êìámenu
        const options = results.videos.map((video, index) => ({
          label: video.title.length > 50 ? video.title.slice(0, 50) + '...' : video.title, // Á¢∫‰øùÊ®ôÁ±§‰∏çË∂ÖÈÅé 25 ÂÄãÂ≠óÁ¨¶
          value: video.url,
          description: `${video.duration.timestamp}`
        }));

        const selectMenu = new StringSelectMenuBuilder()
          .setCustomId('songSelect')
          .setPlaceholder('Ë´ãÈÅ∏Êìá‰∏ÄÈ¶ñÊ≠åÊõ≤')
          .addOptions(options);

        const row = new ActionRowBuilder().addComponents(selectMenu);

        await message.channel.send({ content: 'ÊâæÂà∞‰ª•‰∏ãÊ≠åÊõ≤ÔºåË´ãÈÅ∏ÊìáÔºö', components: [row] });
        // È°ØÁ§∫ÊêúÂ∞ãÁµêÊûú
        // const songs = results.videos.map((video, index) => `**${index + 1}**: ${video.title}`).join('\n');
        // message.channel.send(`ÊâæÂà∞‰ª•‰∏ãÊ≠åÊõ≤Ôºö\n${songs}\nË´ãËº∏ÂÖ•Êï∏Â≠ó‰æÜÈÅ∏ÊìáË¶ÅÊí≠ÊîæÁöÑÊ≠åÊõ≤„ÄÇ`);

        // Á≠âÂæÖÁî®Êà∂Ëº∏ÂÖ•
        const filter = i => i.customId === 'songSelect' && i.user.id === message.author.id;
        const collected = await message.channel.awaitMessageComponent({ filter, time: 30000 }).catch(() => {
          // message.reply('ÈÅ∏ÊìáË∂ÖÊôÇÔºÅ');
        });

        if (collected) {
          url = collected.values[0];
          selectedTitle = options.find(option => option.value === url).label;
          await collected.reply({ content: `Â∑≤ÈÅ∏ÊìáÊ≠åÊõ≤: ${selectedTitle}`, ephemeral: true }); // ephemeralÂè™ÊúâsenderÁúãÁöÑÂà∞
        }

      } else {
        message.reply('Êâæ‰∏çÂà∞‰ªª‰ΩïÈü≥Ê®Ç„ÄÇ');
        return;
      }
    }

    const queue = distube.getQueue(message);

    try {
      const addListStartTime = Date.now();
      console.log('ÈñãÂßãÊäìÈü≥Ê®Ç:', new Date(addListStartTime).toLocaleTimeString());
      if (!queue) {
        // Â¶ÇÊûúÊ≤íÊúâÊí≠ÊîæÊ∏ÖÂñÆÔºåÁõ¥Êé•Êí≠ÊîæÊ≠åÊõ≤
        await distube.play(message.member.voice.channel, url, {
          member: message.member,
          textChannel: message.channel,
          message
        });
      } else {
        // Ëã•Â∑≤ÊúâÊí≠ÊîæÊ∏ÖÂñÆÔºåÂâáÊèíÂÖ•Âà∞ÊúÄÂâçÈù¢
        await distube.play(message.member.voice.channel, url, {
          position: 1, // ÊèíÂÖ•Âà∞ÊúÄÂâçÈù¢
          member: message.member,
          textChannel: message.channel,
          message
        });
      }
    } catch (error) {
      console.error('ÊèíÂÖ•Ê≠åÊõ≤ÊôÇÁôºÁîüÈåØË™§:', error);
      message.reply({ content: 'ÊèíÂÖ•Ê≠åÊõ≤Â§±ÊïóÔºÅ', ephemeral: true });
    }
  }

  if (command === '!skip') {
    const queue = distube.getQueue(message);
    if (!queue) {
      // message.reply('ÁõÆÂâçÊ≤íÊúâÊ≠£Âú®Êí≠ÊîæÁöÑÈü≥Ê®ÇÔºÅ');
      return;
    }

    try {
      if (queue.songs.length > 1) {
        await distube.skip(message);
      } else {
        // Â¶ÇÊûúÊ≤íÊúâ‰∏ã‰∏ÄÈ¶ñÊ≠åÊõ≤ÔºåÂÅúÊ≠¢Êí≠Êîæ
        await distube.stop(message);
      }
    } catch (error) {
      console.error('Ë∑≥Âà∞‰∏ã‰∏ÄÈ¶ñÊôÇÁôºÁîüÈåØË™§:', error);
      // message.reply('ÁÑ°Ê≥ïË∑≥ÈÅéÊ≠åÊõ≤ÔºåÂèØËÉΩÈúÄË¶ÅÊâãÂãïÂπ≤È†ê„ÄÇ');
    }
  }

  // if (command === '!shuffle') {
  //   const queue = distube.getQueue(message);
  //   if (!queue) {
  //     message.reply('ÁõÆÂâçÊ≤íÊúâ‰ªª‰ΩïÊ≠åÊõ≤Âú®Êí≠ÊîæÔºÅ');
  //   } else {
  //     distube.shuffle(queue); // ‰ΩøÁî® shuffle ÊñπÊ≥ïÊâì‰∫ÇÈöäÂàó
  //     // ÂõûË¶ÜÊñ∞ÁöÑÊí≠ÊîæÂàóË°®
  //     const newQueue = queue.songs.map((song, index) =>
  //       `**${index + 1}**. [${song.name}](${song.url}) - \`${song.formattedDuration}\``
  //     ).slice(0, 10).join('\n');

  //     message.channel.send(`üîÄ Êñ∞ÁöÑÊí≠ÊîæÈ†ÜÂ∫èÔºö\n${newQueue}`);
  //   }
  // }

  if (command === '!queue') {
    const queue = distube.getQueue(message);

    if (!queue || queue.songs.length === 0) {
      await message.channel.send('ÁõÆÂâçÊ≤íÊúâÊ≠£Âú®Êí≠ÊîæÁöÑÈü≥Ê®ÇÔºÅ');
      return;
    }

    const pageSize = 10; // ÊØèÈ†ÅÈ°ØÁ§∫ÁöÑÊ≠åÊõ≤Êï∏Èáè
    let currentPage = 0;
    const totalPages = Math.ceil(queue.songs.length-1 / pageSize);

    // ÁîüÊàêÊ∏ÖÂñÆÂµåÂÖ•
    const createQueueEmbed = (page) => {
      const currentQueue = distube.getQueue(message);
      const start = page * pageSize;
      const end = start + pageSize;
      const songs = currentQueue.songs.slice(start, end).slice(1);

      return new EmbedBuilder()
        .setTitle('üéµ ÂæÖÊí≠Ê∏ÖÂñÆ')
        .setDescription(
          songs
            .map(
              (song, index) =>
                `**${start + index + 1}**. [${song.name}](${song.url}) - \`${song.formattedDuration}\``
            )
            .join('\n')
        )
        .setColor('#1DB954')
        .setFooter({ text: `È†ÅÊï∏ ${page + 1} / ${totalPages}` });
    };

    // ÁîüÊàêÊåâÈàï
    const generateButtons = (page) =>
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('previous')
          .setLabel('‚¨ÖÔ∏è')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(page === 0),
        new ButtonBuilder()
          .setCustomId('next')
          .setLabel('‚û°Ô∏è')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(page === totalPages - 1),
        new ButtonBuilder()
          .setCustomId('refresh')
          .setLabel('üîÑ')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('skip')
          .setLabel('‚è≠Ô∏è')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('shuffle')
          .setLabel('üîÄ')
          .setStyle(ButtonStyle.Danger)
      );

    // Êõ¥Êñ∞Ê∏ÖÂñÆÂµåÂÖ•ËàáÊåâÈàï
    const updateQueue = async (interaction) => {
      const currentQueue = distube.getQueue(message);

      if (!currentQueue || currentQueue.songs.length === 0) {
        // Â¶ÇÊûúÊ∏ÖÂñÆÁÇ∫Á©∫ÔºåÈ°ØÁ§∫Ê∏ÖÂñÆÂ∑≤Ê∏ÖÁ©∫
        await interaction.update({
          embeds: [
            new EmbedBuilder()
              .setTitle('üéµ Êí≠ÊîæÊ∏ÖÂñÆÂ∑≤Ê∏ÖÁ©∫')
              .setDescription('ÁõÆÂâçÊ≤íÊúâ‰ªª‰ΩïÊ≠åÊõ≤Âú®Êí≠Êîæ„ÄÇ')
              .setColor('#FF0000'),
          ],
          components: [],
        });
        return;
      }

      const updatedPlayerEmbed = createPlayerEmbed(currentQueue.songs[0], currentQueue.currentTime);
      const updatedQueueEmbed = createQueueEmbed(currentPage);
      const updatedButtons = generateButtons(currentPage);

      await interaction.update({
        embeds: [updatedPlayerEmbed, updatedQueueEmbed],
        components: [updatedButtons]
      });
    };

    const playerEmbed = createPlayerEmbed(queue.songs[0], queue.currentTime);
    const queueEmbed = createQueueEmbed(currentPage);
    const buttons = generateButtons(currentPage);

    const messageEmbed = await message.channel.send({
      embeds: [playerEmbed, queueEmbed],
      components: [buttons]
    });

    const filter = (i) =>
      ['next', 'previous', 'refresh', 'skip', 'shuffle'].includes(i.customId);
    const collector = messageEmbed.createMessageComponentCollector({ filter });

    collector.on('collect', async (interaction) => {
      if (interaction.user.id !== message.author.id) {
        await interaction.reply({ content: '‰Ω†ÁÑ°Ê≥ïÊìç‰ΩúÈÄô‰∫õÊåâÈàïÔºÅ', ephemeral: true });
        return;
      }

      try {
        switch (interaction.customId) {
          case 'next':
            currentPage++;
            break;
          case 'previous':
            currentPage--;
            break;
          case 'refresh':
            break; // Âà∑Êñ∞ÈÇèËºØÔºàË¶ñÈúÄÊ±ÇÔºâ
          case 'skip':
            if (queue.songs.length > 1) {
              await distube.skip(queue);
            } else {
              await distube.stop(queue);
            }
            currentPage = 0; // ÈáçÁΩÆÈ†ÅÊï∏
            break;
          case 'shuffle':
            await distube.shuffle(queue); // Êâì‰∫ÇÊí≠ÊîæÊ∏ÖÂñÆ
            currentPage = 0; // ÈáçÁΩÆÈ†ÅÊï∏
            break;
        }

        // Âú® playSong ‰∫ã‰ª∂‰∏≠ËôïÁêÜÂµåÂÖ•Êõ¥Êñ∞
        updateQueue(interaction)
      } catch (error) {
        console.error(`Êìç‰Ωú ${interaction.customId} ÊôÇÁôºÁîüÈåØË™§:`, error);
        await interaction.reply({ content: 'Êìç‰ΩúÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', ephemeral: true });
      }
    });

    collector.on('end', async () => {
      const disabledButtons = generateButtons(currentPage).components.map((btn) =>
        btn.setDisabled(true)
      );
      await messageEmbed.edit({
        components: [new ActionRowBuilder().addComponents(disabledButtons)]
      });
    });
  }

});


// Áï∂Èü≥Ê®ÇÊí≠ÊîæÂÆåÊàêÊôÇÈÄöÁü•
distube.on('finish', async (queue) => {
  if (idleTimeout) clearTimeout(idleTimeout);

  // Ë®≠ÂÆöÊñ∞ÁöÑË®àÊôÇÂô®ÔºåÂú® 30 ÁßíÂæåËá™ÂãïÊí≠Êîæ‰∏ã‰∏ÄÈ¶ñÊ≠å
  idleTimeout = setTimeout(async () => {
    const currentQueue = distube.getQueue(queue.textChannel.guild.id);

    // Á¢∫‰øù `queue` Âíå `voiceChannel` ‰ªçÁÑ∂ÊúâÊïà
    if (queue.voiceChannel && !currentQueue) {
      try {
        await distube.play(queue.voiceChannel, 'https://www.youtube.com/watch?v=NZoXV828Suo&pp=ygUN5aSa57Gz5aSa576FIA%3D%3D', {
          member: queue.voiceChannel.guild.members.me, // Á¢∫‰øùÂèñÂæóÊ©üÂô®‰∫∫Êú¨Ë∫´ÁöÑ GuildMember
          textChannel: queue.textChannel,
        });
        console.log('ÈöäÂàóÁÇ∫Á©∫Ë∂ÖÈÅé 30 ÁßíÔºåËá™ÂãïÊí≠ÊîæÂΩ±Áâá„ÄÇ');
      } catch (error) {
        console.error('Ëá™ÂãïÊí≠ÊîæÂΩ±ÁâáÊôÇÁôºÁîüÈåØË™§:', error);
      }
    }
  }, 60000); // Ë®≠ÂÆöÁÇ∫ 30 Áßí
});

const createProgressBar = (currentTime, duration, barLength = 20) => {
  const progress = Math.round((currentTime / duration) * barLength);
  const remaining = barLength - progress;
  return '‚ñà'.repeat(progress) + '‚ñë'.repeat(remaining);
};

const createPlayerEmbed = (song, currentTime = 0) => {
  const elapsedMinutes = Math.floor(currentTime / 60);
  const elapsedSeconds = Math.floor(currentTime % 60).toString().padStart(2, '0');
  const elapsed = `${elapsedMinutes}:${elapsedSeconds}`;

  return new EmbedBuilder()
    .setColor('#7785CC') // Spotify Á∂†Ëâ≤
    .setTitle(`üé∂ ${song.name}`)
    .addFields(
      { name: 'üîä', value: ` ${elapsed} / ${song.formattedDuration}` },
      // { name: 'üîä ÈÄ≤Â∫¶Ê¢ù', value: `\`\`\`${progressBar}\`\`\`` }
    )
    .setThumbnail(song.thumbnail);
};

const updateMessage = async (queue, message, buttons) => {
  const currentSong = queue.songs[0];
  const currentTime = queue.currentTime;
  // const progressBar = createProgressBar(currentTime, currentSong.duration);

  const embed = createPlayerEmbed(currentSong, currentTime);

  await message.edit({ embeds: [embed], components: [buttons] });
};

distube
  
  .on('playSong', async (queue, song) => {
    // const voiceChannel = queue.voiceChannel || queue.member.voice.channel; // Âæû queue ‰∏≠Áç≤ÂèñË™ûÈü≥È†ªÈÅì
    // const songName = song.name.length > 20 ? song.name.slice(0, 20) + '...' : song.name;
    // try {
    //   await client.user.setActivity(`üé∂ ${song.name}`, { type: 'LISTENING' });
    //   console.log(`Ê©üÂô®‰∫∫ÁãÄÊÖãÂ∑≤Êõ¥Êñ∞ÁÇ∫: Ê≠£Âú®Êí≠Êîæ ${song.name}`);
    // } catch (error) {
    //   console.error(`ÁÑ°Ê≥ïÊõ¥Êñ∞Ê©üÂô®‰∫∫ÁãÄÊÖã: ${error}`);
    // }
    // Â¶ÇÊûúÊúâÊñ∞Èü≥Ê®ÇÊí≠ÊîæÔºåÊ∏ÖÈô§Ë®àÊôÇÂô®
    if (idleTimeout) {
      clearTimeout(idleTimeout);
      idleTimeout = null;
    }
    console.log(`[${new Date(Date.now()).toLocaleTimeString()}] Ê≠£Âú®Êí≠Êîæ: ${song.name}`);
    // if (message) {
    //   await updateEmbedMsg(queue);
    // }
  })

  .on('addList', async (queue, playlist) => {
    const playTime = Date.now();
    console.log('ÊäìÂÆåÈü≥Ê®Ç:', new Date(playTime).toLocaleTimeString());

    if (!queue || queue.songs.length === 0) {
      await message.channel.send('ÁõÆÂâçÊ≤íÊúâÊ≠£Âú®Êí≠ÊîæÁöÑÈü≥Ê®ÇÔºÅ');
      return;
    }

    const pageSize = 10; // ÊØèÈ†ÅÈ°ØÁ§∫ÁöÑÊ≠åÊõ≤Êï∏Èáè
    let currentPage = 0;

    // ÂãïÊÖãË®àÁÆóÁ∏ΩÈ†ÅÊï∏
    const calculateTotalPages = (songs) => Math.ceil(songs.length / pageSize);

    // ÁîüÊàêÊ∏ÖÂñÆÂµåÂÖ•
    const createQueueEmbed = (page) => {
      const currentQueue = distube.getQueue(queue.textChannel.guild.id);
      const totalPages = calculateTotalPages(currentQueue.songs);
      const start = page * pageSize;
      const end = start + pageSize;
      const songs = currentQueue.songs.slice(1).slice(start, end); // Ë∑≥ÈÅéÊ≠£Âú®Êí≠ÊîæÁöÑÁ¨¨‰∏ÄÈ¶ñ

      return new EmbedBuilder()
        .setTitle('üéµ ÂæÖÊí≠Ê∏ÖÂñÆ')
        .setDescription(
          songs.length > 0
            ? songs
              .map(
                (song, index) =>
                  `**${start + index + 1}**. [${song.name}](${song.url}) - \`${song.formattedDuration}\``
              )
              .join('\n')
            : 'üé∂ Ê∏ÖÂñÆ‰∏≠Ê≤íÊúâÊõ¥Â§öÊ≠åÊõ≤'
        )
        .setColor('#1DB954')
        .setFooter({ text: `È†ÅÊï∏ ${page + 1} / ${totalPages}` });
    };

    // ÁîüÊàêÊåâÈàï
    const generateButtons = (page) => {
      const totalPages = calculateTotalPages(queue.songs);

      return new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('previous')
          .setLabel('‚¨ÖÔ∏è')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(page === 0),
        new ButtonBuilder()
          .setCustomId('next')
          .setLabel('‚û°Ô∏è')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(page === totalPages - 1), // Â§öË∑≥Á¨¨‰∏ÄÈ¶ñÊ≠å
        new ButtonBuilder()
          .setCustomId('refresh')
          .setLabel('üîÑ')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('skip')
          .setLabel('‚è≠Ô∏è')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('shuffle')
          .setLabel('üîÄ')
          .setStyle(ButtonStyle.Danger)
      );
    };

    // Êõ¥Êñ∞ÂµåÂÖ•ËàáÊåâÈàï
    const updateQueue = async (interaction) => {
      const currentQueue = distube.getQueue(queue.textChannel.guild.id);

      if (!currentQueue || currentQueue.songs.length === 0) {
        await interaction.update({
          embeds: [
            new EmbedBuilder()
              .setTitle('üéµ Êí≠ÊîæÊ∏ÖÂñÆÂ∑≤Ê∏ÖÁ©∫')
              .setDescription('ÁõÆÂâçÊ≤íÊúâ‰ªª‰ΩïÊ≠åÊõ≤Âú®Êí≠Êîæ„ÄÇ')
              .setColor('#FF0000'),
          ],
          components: [],
        });
        return;
      }

      const updatedPlayerEmbed = createPlayerEmbed(currentQueue.songs[0], currentQueue.currentTime);
      const updatedQueueEmbed = createQueueEmbed(currentPage);
      const updatedButtons = generateButtons(currentPage);

      await interaction.update({
        embeds: [updatedPlayerEmbed, updatedQueueEmbed],
        components: [updatedButtons],
      });
    };

    // ÂàùÂßãÂåñÂµåÂÖ•ËàáÊåâÈàï
    const playerEmbed = createPlayerEmbed(queue.songs[0], queue.currentTime);
    const queueEmbed = createQueueEmbed(currentPage);
    const buttons = generateButtons(currentPage);

    const messageEmbed = await queue.textChannel.send({
      embeds: [playerEmbed, queueEmbed],
      components: [buttons],
    });

    // ÊåâÈàï‰∫§‰∫íËôïÁêÜÈÇèËºØ
    const filter = (i) =>
      ['next', 'previous', 'refresh', 'skip', 'shuffle'].includes(i.customId);
    const collector = messageEmbed.createMessageComponentCollector({ filter });

    collector.on('collect', async (interaction) => {
      try {
        switch (interaction.customId) {
          case 'next':
            currentPage++;
            break;
          case 'previous':
            currentPage--;
            break;
          case 'refresh':
            break; // Âà∑Êñ∞ÈÇèËºØ
          case 'skip':
            if (queue.songs.length > 1) {
              await distube.skip(queue);
            } else {
              await distube.stop(queue);
            }
            currentPage = 0; // ÈáçÁΩÆÈ†ÅÊï∏
            break;
          case 'shuffle':
            await distube.shuffle(queue); // Êâì‰∫ÇÊí≠ÊîæÊ∏ÖÂñÆ
            currentPage = 0; // ÈáçÁΩÆÈ†ÅÊï∏
            break;
        }

        await updateQueue(interaction); // Êõ¥Êñ∞ÂµåÂÖ•ËàáÊåâÈàï
      } catch (error) {
        console.error(`Êìç‰Ωú ${interaction.customId} ÊôÇÁôºÁîüÈåØË™§:`, error);
        await interaction.reply({ content: 'Êìç‰ΩúÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', ephemeral: true });
      }
    });

    collector.on('end', async () => {
      const disabledButtons = generateButtons(currentPage).components.map((btn) =>
        btn.setDisabled(true)
      );
      await messageEmbed.edit({
        components: [new ActionRowBuilder().addComponents(disabledButtons)],
      });
    });
  })

  .on('error', (queue, error) => {
    console.error(`Êí≠ÊîæÊ∏ÖÂñÆÊàñÊ≠åÊõ≤ÊôÇÁôºÁîüÈåØË™§: ${error.message}`);
    // queue.textChannel?.send(`Êí≠ÊîæÊ∏ÖÂñÆ‰∏≠ÁöÑÊüêÈ¶ñÊ≠åÊõ≤ÁôºÁîüÈåØË™§: ${error.message}`);

    // Ëá™ÂãïË∑≥ÈÅéÈåØË™§Ê≠åÊõ≤
    const song = queue.songs[0];
    if (song) {
      queue.textChannel?.send(`Ê≠£Âú®Ë∑≥ÈÅéÁôºÁîüÈåØË™§ÁöÑÊ≠åÊõ≤: ${song.name}`);
      try {
        distube.skip(queue);
      } catch (err) {
        console.error('Ë∑≥ÈÅéÊ≠åÊõ≤ÊôÇÁôºÁîüÈåØË™§:', err);
        queue.textChannel?.send('ÁÑ°Ê≥ïË∑≥ÈÅéË©≤Ê≠åÊõ≤ÔºåÂèØËÉΩÈúÄË¶ÅÊâãÂãïÂπ≤È†ê„ÄÇ');
      }
    }
  });


// ÁôªÂÖ•Ê©üÂô®‰∫∫
client.login(DISCORD_BOT_TOKEN);
